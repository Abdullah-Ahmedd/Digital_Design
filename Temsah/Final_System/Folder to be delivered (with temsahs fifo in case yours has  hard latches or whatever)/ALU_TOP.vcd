$date
	Sun Sep 14 21:13:04 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_ALU_TOP $end
$var wire 16 ! Shift_OUT [15:0] $end
$var wire 1 " Shift_Flag $end
$var wire 16 # Logic_OUT [15:0] $end
$var wire 1 $ Logic_Flag $end
$var wire 16 % CMP_OUT [15:0] $end
$var wire 1 & CMP_Flag $end
$var wire 32 ' Arith_OUT [31:0] $end
$var wire 1 ( Arith_Flag $end
$var parameter 32 ) Width $end
$var reg 16 * A [15:0] $end
$var reg 4 + ALU_FUN [3:0] $end
$var reg 16 , B [15:0] $end
$var reg 1 - CLK $end
$var reg 1 . RST $end
$scope module DUT $end
$var wire 16 / A [15:0] $end
$var wire 4 0 ALU_FUN [3:0] $end
$var wire 16 1 B [15:0] $end
$var wire 1 - CLK $end
$var wire 1 . RST $end
$var wire 16 2 Shift_OUT [15:0] $end
$var wire 1 " Shift_Flag $end
$var wire 1 3 Shift_Enable_internal $end
$var wire 16 4 Logic_OUT [15:0] $end
$var wire 1 $ Logic_Flag $end
$var wire 1 5 Logic_Enable_internal $end
$var wire 16 6 CMP_OUT [15:0] $end
$var wire 1 & CMP_Flag $end
$var wire 1 7 CMP_Enable_internal $end
$var wire 32 8 Arith_OUT [31:0] $end
$var wire 1 ( Arith_Flag $end
$var wire 1 9 Arith_Enable_internal $end
$var parameter 32 : Width $end
$scope module ARU1 $end
$var wire 16 ; A [15:0] $end
$var wire 2 < ALU_FUN [1:0] $end
$var wire 16 = B [15:0] $end
$var wire 1 - CLK $end
$var wire 1 . RST $end
$var wire 1 9 Arith_Enable $end
$var parameter 2 > ADD $end
$var parameter 2 ? DIV $end
$var parameter 2 @ MUL $end
$var parameter 2 A SUB $end
$var parameter 32 B Width $end
$var reg 1 ( Arith_Flag $end
$var reg 32 C Arith_OUT [31:0] $end
$upscope $end
$scope module CMPU1 $end
$var wire 16 D A [15:0] $end
$var wire 2 E ALU_FUN [1:0] $end
$var wire 16 F B [15:0] $end
$var wire 1 - CLK $end
$var wire 1 . RST $end
$var wire 1 7 CMP_Enable $end
$var parameter 2 G CMPEQ $end
$var parameter 2 H CMPG $end
$var parameter 2 I CMPL $end
$var parameter 2 J NOP $end
$var parameter 32 K Width $end
$var reg 1 & CMP_Flag $end
$var reg 16 L CMP_OUT [15:0] $end
$upscope $end
$scope module D1 $end
$var wire 2 M ALU_FUN [1:0] $end
$var parameter 2 N Arith $end
$var parameter 2 O CMP $end
$var parameter 2 P Logic $end
$var parameter 2 Q Shift $end
$var reg 1 9 Arith_Enable $end
$var reg 1 7 CMP_Enable $end
$var reg 1 5 Logic_Enable $end
$var reg 1 3 Shift_Enable $end
$upscope $end
$scope module LU1 $end
$var wire 16 R A [15:0] $end
$var wire 2 S ALU_FUN [1:0] $end
$var wire 16 T B [15:0] $end
$var wire 1 - CLK $end
$var wire 1 5 Logic_Enable $end
$var wire 1 . RST $end
$var parameter 2 U AND $end
$var parameter 2 V NAND $end
$var parameter 2 W NOR $end
$var parameter 2 X OR $end
$var parameter 32 Y Width $end
$var reg 1 $ Logic_Flag $end
$var reg 16 Z Logic_OUT [15:0] $end
$upscope $end
$scope module SHU1 $end
$var wire 16 [ A [15:0] $end
$var wire 2 \ ALU_FUN [1:0] $end
$var wire 16 ] B [15:0] $end
$var wire 1 - CLK $end
$var wire 1 . RST $end
$var wire 1 3 Shift_Enable $end
$var parameter 2 ^ SHLA $end
$var parameter 2 _ SHLB $end
$var parameter 2 ` SHRA $end
$var parameter 2 a SHRB $end
$var parameter 32 b Width $end
$var reg 1 " Shift_Flag $end
$var reg 16 c Shift_OUT [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000 b
b10 a
b0 `
b11 _
b1 ^
b10000 Y
b1 X
b11 W
b10 V
b0 U
b11 Q
b1 P
b10 O
b0 N
b10000 K
b0 J
b11 I
b10 H
b1 G
b10000 B
b1 A
b10 @
b11 ?
b0 >
b10000 :
b10000 )
$end
#0
$dumpvars
b0 c
b0 ]
b0 \
b0 [
b0 Z
b0 T
b0 S
b0 R
b0 M
b0 L
b0 F
b0 E
b0 D
b0 C
b0 =
b0 <
b0 ;
19
b0 8
07
b0 6
05
b0 4
03
b0 2
b0 1
b0 0
b0 /
0.
0-
b0 ,
b0 +
b0 *
0(
b0 '
0&
b0 %
0$
b0 #
0"
b0 !
$end
#5000
1-
#10000
0-
#12000
b101 ,
b101 1
b101 =
b101 F
b101 T
b101 ]
b1010 *
b1010 /
b1010 ;
b1010 D
b1010 R
b1010 [
1.
#15000
1(
b1111 '
b1111 8
b1111 C
1-
#20000
0-
#22000
b1 <
b1 S
b1 E
b1 \
b1 +
b1 0
b111 ,
b111 1
b111 =
b111 F
b111 T
b111 ]
b1111 *
b1111 /
b1111 ;
b1111 D
b1111 R
b1111 [
#25000
b1000 '
b1000 8
b1000 C
1-
#30000
0-
#32000
15
09
b1 M
b0 <
b0 S
b0 E
b0 \
b100 +
b100 0
b111111110000 ,
b111111110000 1
b111111110000 =
b111111110000 F
b111111110000 T
b111111110000 ]
b1111111100000000 *
b1111111100000000 /
b1111111100000000 ;
b1111111100000000 D
b1111111100000000 R
b1111111100000000 [
#35000
0(
b0 '
b0 8
b0 C
1$
b111100000000 #
b111100000000 4
b111100000000 Z
1-
#40000
0-
#42000
b1 <
b1 S
b1 E
b1 \
b101 +
b101 0
b11111111 ,
b11111111 1
b11111111 =
b11111111 F
b11111111 T
b11111111 ]
b1010101001010101 *
b1010101001010101 /
b1010101001010101 ;
b1010101001010101 D
b1010101001010101 R
b1010101001010101 [
#45000
b1010101011111111 #
b1010101011111111 4
b1010101011111111 Z
1-
#50000
0-
#52000
17
05
b10 M
b0 <
b0 S
b0 E
b0 \
b1000 +
b1000 0
b10 ,
b10 1
b10 =
b10 F
b10 T
b10 ]
b1111 *
b1111 /
b1111 ;
b1111 D
b1111 R
b1111 [
#55000
0$
b0 #
b0 4
b0 Z
1&
1-
#60000
0-
#62000
13
07
b11 M
b1100 +
b1100 0
b11001 ,
b11001 1
b11001 =
b11001 F
b11001 T
b11001 ]
b11001 *
b11001 /
b11001 ;
b11001 D
b11001 R
b11001 [
#65000
1"
b1100 !
b1100 2
b1100 c
0&
1-
#70000
0-
#72000
b1 <
b1 S
b1 E
b1 \
b1101 +
b1101 0
b1010 ,
b1010 1
b1010 =
b1010 F
b1010 T
b1010 ]
b11110 *
b11110 /
b11110 ;
b11110 D
b11110 R
b11110 [
#75000
b111100 !
b111100 2
b111100 c
1-
#80000
0-
#85000
1-
#90000
0-
#95000
1-
#100000
0-
#102000
